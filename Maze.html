<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Escape — Player vs AI</title>
  <style>
    :root{--cell:28px;--gap:2px}
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:16px;background:#0f172a;color:#e6eef8}
    h1{font-size:20px;margin:0 0 8px}
    #game{display:flex;gap:18px;align-items:flex-start}
    #board{background:#07122b;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,.6)}
    canvas{background:#0b1629;display:block;border-radius:6px}
    #ui{max-width:320px}
    .panel{background:#081229;padding:12px;border-radius:10px;margin-bottom:12px}
    button{background:#1f6feb;color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    p{margin:6px 0}
    small{color:#9fb0d4}
    .legend span{display:inline-block;margin-right:10px}
    .legend em{display:inline-block;width:14px;height:14px;vertical-align:middle;margin-right:6px;border-radius:3px}
  </style>
</head>
<body>
  <h1>Maze Escape — Reach the Exit (E) while avoiding the Enemy (X)</h1>
  <div id="game">
    <div id="board">
      <canvas id="canvas" width="560" height="560"></canvas>
    </div>
    <div id="ui">
      <div class="panel">
        <p><strong>Controls:</strong> W/A/S/D or Arrow keys</p>
        <p><strong>Goal:</strong> Reach the green <em>E</em> square. Don't let <em>X</em> catch you.</p>
        <p class="legend"><span><em style="background:#d9d9d9"></em> Wall</span><span><em style="background:#071b2b"></em> Path</span><span><em style="background:#ffd166"></em> Player</span><span><em style="background:#ef476f"></em> Enemy</span><span><em style="background:#06d6a0"></em> Exit</span></p>
      </div>
      <div class="panel">
        <p><strong>Status:</strong> <span id="status">Playing</span></p>
        <p><strong>Moves:</strong> <span id="moves">0</span></p>
        <p><strong>Enemy steps:</strong> <span id="esteps">0</span></p>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="reset">New Maze</button>
          <button id="easy">Easy AI</button>
          <button id="hard">Hard AI</button>
        </div>
      </div>
      <div class="panel">
        <p><small>Notes: The AI tries to move towards the player. "Easy AI" moves randomly; "Hard AI" moves greedily (shorter paths).</small></p>
      </div>
    </div>
  </div>  <script>
    // Maze Escape (single-file) — simple grid maze, player moves, AI enemy.
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const movesEl = document.getElementById('moves');
    const estepsEl = document.getElementById('esteps');
    const resetBtn = document.getElementById('reset');
    const easyBtn = document.getElementById('easy');
    const hardBtn = document.getElementById('hard');

    const ROWS = 20; const COLS = 20;
    const CELL = Math.floor(canvas.width / COLS);

    let grid = [];
    let player = {r:1,c:1};
    let enemy = {r:ROWS-2,c:COLS-2};
    let exitCell = {r:ROWS-2,c:COLS-3};
    let moves = 0; let esteps = 0;
    let playing = true;
    let aiMode = 'hard'; // 'easy' or 'hard'

    function makeEmptyGrid(){
      grid = new Array(ROWS).fill(0).map(()=>new Array(COLS).fill(1));
    }

    // Maze generator: randomized DFS (recursive backtracker) on odd cells
    function generateMaze(){
      makeEmptyGrid();
      // Carve passages on odd indices
      for(let r=1;r<ROWS;r+=2){
        for(let c=1;c<COLS;c+=2){
          grid[r][c] = 0;
        }
      }
      const dirs = [[0,2],[0,-2],[2,0],[-2,0]];
      function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
      const visited = new Set();
      function key(r,c){return r+','+c}
      function carve(r,c){
        visited.add(key(r,c));
        let d = shuffle(dirs.slice());
        for(const [dr,dc] of d){
          let nr=r+dr, nc=c+dc;
          if(nr>0 && nr<ROWS && nc>0 && nc<COLS && !visited.has(key(nr,nc))){
            grid[r+dr/2][c+dc/2]=0; // carve between
            grid[nr][nc]=0;
            carve(nr,nc);
          }
        }
      }
      carve(1,1);
      // Ensure start/end are open
      player = {r:1,c:1};
      exitCell = {r:ROWS-2,c:COLS-2};
      enemy = {r:ROWS-2,c:COLS-3};
      grid[player.r][player.c]=0; grid[exitCell.r][exitCell.c]=0; grid[enemy.r][enemy.c]=0;
      moves=0;esteps=0;playing=true;updateUI();
      statusEl.textContent='Playing';
      draw();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x=c*CELL, y=r*CELL;
          if(grid[r][c]===1){ ctx.fillStyle='#d9d9d9'; ctx.fillRect(x,y,CELL-1,CELL-1); }
          else{ ctx.fillStyle='#071b2b'; ctx.fillRect(x,y,CELL-1,CELL-1); }
        }
      }
      // Exit
      ctx.fillStyle='#06d6a0'; ctx.fillRect(exitCell.c*CELL, exitCell.r*CELL, CELL-1, CELL-1);
      // Player
      ctx.fillStyle='#ffd166'; ctx.fillRect(player.c*CELL+4, player.r*CELL+4, CELL-9, CELL-9);
      drawText('P', player.r, player.c);
      // Enemy
      ctx.fillStyle='#ef476f'; ctx.fillRect(enemy.c*CELL+4, enemy.r*CELL+4, CELL-9, CELL-9);
      drawText('X', enemy.r, enemy.c);
    }

    function drawText(ch, r, c){
      ctx.fillStyle = '#06202b';
      ctx.font = Math.max(12, CELL/2)+'px sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(ch, c*CELL + CELL/2, r*CELL + CELL/2 + 1);
    }

    function updateUI(){ movesEl.textContent = moves; estepsEl.textContent = esteps; }

    function tryMovePlayer(dr,dc){ if(!playing) return; const nr=player.r+dr, nc=player.c+dc; if(nr<0||nr>=ROWS||nc<0||nc>=COLS) return; if(grid[nr][nc]===1) return; player.r=nr; player.c=nc; moves++; updateUI(); checkWinLose(); if(playing){ enemyTurn(); } draw(); }

    function checkWinLose(){
      if(player.r===exitCell.r && player.c===exitCell.c){ statusEl.textContent='You Win!'; playing=false; }
      else if(player.r===enemy.r && player.c===enemy.c){ statusEl.textContent='Caught — You Lose'; playing=false; }
    }

    // AI: easy = random valid step; hard = greedy towards player preferring steps that reduce manhattan distance
    function enemyTurn(){ if(!playing) return; esteps++; const movesList = getNeighbors(enemy.r, enemy.c);
      if(movesList.length===0) return;
      let choice;
      if(aiMode==='easy' && Math.random() < 0.7){ choice = movesList[Math.floor(Math.random()*movesList.length)]; }
      else {
        // choose neighbor that minimizes manhattan distance
        let best = 1e9; let bestMoves=[];
        for(const m of movesList){ const d = Math.abs(m.r-player.r)+Math.abs(m.c-player.c); if(d<best){ best=d; bestMoves=[m]; } else if(d===best) bestMoves.push(m); }
        choice = bestMoves[Math.floor(Math.random()*bestMoves.length)];
      }
      enemy.r = choice.r; enemy.c = choice.c; updateUI(); checkWinLose(); }

    function getNeighbors(r,c){ const out=[]; const dirs=[[0,1],[0,-1],[1,0],[-1,0]]; for(const [dr,dc] of dirs){ const nr=r+dr, nc=c+dc; if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS && grid[nr][nc]===0) out.push({r:nr,c:nc}); } return out; }

    // Keyboard
    window.addEventListener('keydown', e=>{
      const k = e.key.toLowerCase();
      if(['arrowup','w'].includes(e.key.toLowerCase())){ e.preventDefault(); tryMovePlayer(-1,0);} 
      else if(['arrowdown','s'].includes(e.key.toLowerCase())){ e.preventDefault(); tryMovePlayer(1,0);} 
      else if(['arrowleft','a'].includes(e.key.toLowerCase())){ e.preventDefault(); tryMovePlayer(0,-1);} 
      else if(['arrowright','d'].includes(e.key.toLowerCase())){ e.preventDefault(); tryMovePlayer(0,1);} 
    });

    // Buttons
    resetBtn.addEventListener('click', generateMaze);
    easyBtn.addEventListener('click', ()=>{ aiMode='easy'; easyBtn.textContent='Easy AI ✓'; hardBtn.textContent='Hard AI'; });
    hardBtn.addEventListener('click', ()=>{ aiMode='hard'; hardBtn.textContent='Hard AI ✓'; easyBtn.textContent='Easy AI'; });

    // init
    generateMaze();

    // Mobile touch controls (simple): swipe detection
    let startX=null, startY=null;
    canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; startX=t.clientX; startY=t.clientY; });
    canvas.addEventListener('touchend', e=>{ if(startX===null) return; const t=e.changedTouches[0]; const dx=t.clientX-startX, dy=t.clientY-startY; if(Math.abs(dx)>Math.abs(dy)){ if(dx>20) tryMovePlayer(0,1); else if(dx<-20) tryMovePlayer(0,-1);} else { if(dy>20) tryMovePlayer(1,0); else if(dy<-20) tryMovePlayer(-1,0);} startX=null; startY=null; });

    // Helpful: allow clicking on canvas to move (if adjacent)
    canvas.addEventListener('click', e=>{
      const rect = canvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; const c = Math.floor(x/CELL), r = Math.floor(y/CELL);
      const dr = r-player.r, dc = c-player.c;
      if(Math.abs(dr)+Math.abs(dc)===1) tryMovePlayer(dr,dc);
    });

    // Make canvas crisp on high DPI
    (function adjustDPI(){ const dpr = window.devicePixelRatio||1; canvas.width = COLS*CELL*dpr; canvas.height = ROWS*CELL*dpr; canvas.style.width = COLS*CELL+'px'; canvas.style.height = ROWS*CELL+'px'; ctx.setTransform(dpr,0,0,dpr,0,0); draw(); })();
  </script></body>
</html>
